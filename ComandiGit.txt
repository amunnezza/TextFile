innanzitutto entra in una directory e fai 
git init // crea un repository
ls -A // mostra tutti i file che git crea

CONFIGURAZIONE INIZIALE
git help NomeComando

git config --global user.name "Nome da usare"

git config --global user.email "mail@daUsare.com" // quella che usi su git-hub.com

git config --global core.editor notepad++  // per decidere quale editor usare

PRIMI ESEMPI 
touch nomefile.txt    // per creare un nuovo file

git status   //  mostra se ci sono delle cose aggiunte ma non ancora prese in considerazione

git add NomeFile.txt // dice di fare Track del NomeFile.txt

//nota bene tra modifica del file e il comnado git add nomeFile.txt posso fare
git diff   // mi dice quale è la differenza rispetto a quello gia in stage o in commit

nota bene la gestione dei commit puoi farla 
gitk --all // interfaccia grafica carina e funzionante

OSSERVARE CAMBIAMENTI
$ git log // mostra tutti i log

$ git log -1 // mostra solo l'ultimo
$ git log --stat // molto utile da lista commit con 
				 // parti file cambiate

osservare commits 

the --stat flag what files were modified and how many lines of code 
we could see exactly changes 
Being able to see exact changes made to a file important
example in the blog project the commit a3dc99a 
 message "center content on page" and modifies the CSS file 
 by adding 5 lines. 
 What are those five lines that were added? 
 How can we figure out what those 5 lines are?

recap of the git log -p output:

 the file that is being displayed
 - the hash of first second version of the file
not usually important, so it's safe to ignore
- the old version and current version of the file
- the lines where the file is added and how many lines there are
	-15,83 indicates that the old version (represented by the -) started at line 15 and that the file had 83 lines
	+15,85 indicates that the current version (represented by the +) starts at line 15 and that there are now 85 lines...
	  these 85 lines are shown in the patch below
- the actual changes made in the commit
lines red and with a minus (-) were original version removed by the commit
lines green with a plus (+) are new lines in the commit

// git log -p --stat 
display stats info above the patch info.
order doesn't matter git log --stat -p also show the stats 
info above the patch info.
git log -p -w show the patch information but not highlight 
	only whitespace changes have occurred.
// se cambi il file e poi 
$ git add nomeFile.txt
 
	Too Much Scrolling
scrolling and scrolling  patch output to the right 
be super handy display a specific commit's 

There are actually two ways to do this!
-providing the SHA of the commit you want to see to git log
-use a new command git show
You already know how to "log" information with:

git log
git log --oneline
git log --stat
git log -p

But you can supply the SHA of a commit as ARGUMENT FOR ALL THIS COMMAND
 $ git log -p fdf5493
 MOSTRA TUTTI A PARTIRE DAL LOG CON QUELLA FIRMA
 
** New Command: git show
shows a specific commit 

$ git show
will  display the most recent commit. 
Typically, a SHA is provided as a final argument:

$ git show fdf5493

What does git show do?
The git show command will show only one commit. 
The output of the git show is the same as the git log -p command. 
So by default, git show displays:
the commit
the author
the date
the commit message
the patch information
However, git show can be combined with most of the other flags 
we've looked at:

--stat - to show the how many files were changed and the number of lines that were added/removed
-p or --patch - this the default, but if --stat is used, the patch won't display, so pass -p to add it again
-w - to ignore changes to whitespace

// ora git diff  NON ti da nulla!!
// Perchè non cì sono differenxe tra il file in lavorazione e quello in stage!!
// ma facendo 
$ git diff --staged   // mostra differenze tra file staged e quello gia committato

// nota bene posso vedere differenze tra i vari commit 

FINORA FATTO FONDAZIONI CON 	
git init // inizializzare 
AGGIUNGERE FILE ALLO STAGING
The git add command is used to move files from the Working Directory to the Staging Index.

$ git add <file1> <file2> … <fileN>

This command takes a space-separated list of file names
alternatively, the period . can be used to tell Git to add the current directory
 (and all nested files)
// per aggiungere tutti fai 
$ git add --all
$ git add . // aggiunge tutto anche directory e sotto directory
$ git status // ti dice non ancora commitato
$ git commit -am "messaggio di commit"


git diff "hash del commit che mi interessa"
PER FARLO USO IL CONCETTO DI "HEAD" CHE SI VEDE NEL git log . 	HEAD E' L'ULTIMO COMMIT VALIDO E PER 
TORNARE AD UNO STADIO PRECEDENTE PUOI FARE 	
git checkout~3 (torna indietro di tre) 


PER TORNARE INDIETRO SU UN SINGOLO FILE PUOI FARE
git checkout HEAD~3 list.txt

OPPURE TORNARE ALLA PRINCIPALE INIZIALE CON 
git checkout HEAD list.txt


// SA FACCIO DEGLI ERRORI SUI FILE POSSO TORNARE INDIETRO 
// SUPPONGO DI AVERE AGGIUNTO QUALCOSA DI SBABLIATO SU list.txt  E HO GIA FATTO
git add list.txt
git commit -m "ho fatto qui errore"

PER CORREGERE

git reset HEAD~1   // il file cambiato sbagliato rimane in staging
git reset HEAD~1 --mixed // il file cambiato viene tolto dallo staging ma le modifiche rimandono sul file sys
git reset HEAD~1 --hard // come mixed ma cambia anche il file sul file sys

TAG 
Is an extra label


BRANCH
	Creiamo due ulteriori branch uno per dairy e l'altro per meat
	IL VANTAGGIO EVIDENTE E CHE POSSO AVERE DUE TEAM CHE LAVORANO SU PARTI DIVERSE ANCHE DELLO STESSO FILE 
	SENZA DARSI FASTIDIO. PER ESEMPIO SUPPONIAMO DI AVER UN TEAM CHE LAVORA SULLA PARTE DAIRY 	E UN ALTRO SULLA
	PATE MEAT. ALLORA 	
$ git branch ( mi dice quali branch ci sono e quello attivo al momneto)
//IN PRIMA ISTANZA HO SOLO *master con asterisco che MI DICE QUALE E QUELLO ATTIVO
git branch meat // crea il branch meat
git branch dairy // crea il branch dairy
// POI MI SPOSTO SUL BRANCH AD ES. DAIRY
git checkout DAIRY
// E MENTRE SONO SU DAIRY modifico list.txt aggiungendo qualcosa sotto dairy ad es. milk , egg ecc. 
// add e commit 
$git add list.txt
$ git commit -m "aggiunte voci a dairy"  //MA E COMMIT VISUALIZZABILE SOOLO DAL BRANCH DAIRY 
// SE TORNO SU MASTER O SULL'ALTRO BRANCH LE MODIFICHE NON SONO VISIBILI
// INFATTI FACENDO 
$ git checkout master // se controlo list.txt le modifiche fatte in BRANCH dairy non sono visibili
/// ANALOGAMENTE SU MEAT POSSO FARE
$ git checkout MEAT
$ notepad++ list.txt
// AGGIUNGO DELLE VOCI IN MEAT
	git add list.txt
	git commit -m "aggiunta della carne"
// ache qui se torno in branch master 
$ git checkout master
$ notepad++ list.txt // il file risulta non cambiato



QUINDI CAPITO L'UTILITA A UN CERTO PUNTO DEVO FONDERE LE DUE BRANCH IN MASTER
PER FARLO PRIMA ENTRO IN MASTER
$ git checkout master
POI FACCIO IL MERGE
$ git merge meat  // controlla che ha aggiunto meat
$ git merge DAIRY // CONTROLLA CHE HA AGGIUNTO DAIRY



GIT HUD 

crea un repository su git-hub.com
per es. TextFile
e SINCRONIZZA IL NOSTRO REPOSITORY CON QUELLO SUL GIT HUB USANDO REMOTE 

$ git remote add origin "https://github.com/amunnezza/TextFile.git"   // LEGGERE 	git help remote
// CREATO UN ALIAS origin per l'url scritto
// se faccio 
& git remote -v // mi da l'url del repository remoto
// a questo punto posso FARE IL PUSH DEL REPOSITORY dal locale verso remoto 
$ git push origin master  // verso  dovE? origin che è un alias Che cosa? il branch master

//rimane da vedere clone di un repository
// CHIARAMENTE OTTIMA IDEA FARE IN UN ALTRA DIRECTORY
mkdir newDir
cd newDir

$ git clone "URL CHE MI INTERESSA" 

VEDERE PèOI DA SOLO I COMANDI
git fetch 
git pull 
// NECESSARI PER LAVORI IN GRUPPO



